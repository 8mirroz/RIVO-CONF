name: lock-check
on:
  pull_request:

jobs:
  lock:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Lock enforcement
        uses: actions/github-script@v7
        env:
          LOCK_PROJECT_ID: ${{ secrets.LOCK_PROJECT_ID }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const pr = context.payload.pull_request;
            if (!pr) {
              core.setFailed('No PR context');
              return;
            }

            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const files = await github.paginate(github.rest.pulls.listFiles, {
              owner,
              repo,
              pull_number: pr.number,
              per_page: 100
            });

            const changedFiles = files.map(f => f.filename);
            const body = pr.body || '';

            const projectId = process.env.LOCK_PROJECT_ID;
            let lockPaths = [];
            let lockOwner = null;
            let lockType = null;
            let lockExpiry = null;

            const parseBodyField = (fieldName) => {
              const match = body.match(new RegExp(`^\\s*[-*]?\\s*${fieldName}\\s*:\\s*(.+)$`, 'im'));
              return match ? match[1].trim() : '';
            };

            if (projectId) {
              const issueMatch = body.match(/^\s*[-*]?\s*Issue\s*:\s*#(\d+)\s*$/im);
              if (!issueMatch) {
                core.setFailed('Missing `Issue: #<number>` in PR body (required for strict lock-check)');
                return;
              }
              const issueNumber = parseInt(issueMatch[1], 10);
              const query = `
                query($owner:String!, $repo:String!, $number:Int!) {
                  repository(owner:$owner, name:$repo) {
                    issue(number:$number) {
                      projectItems(first:20) {
                        nodes {
                          project { id }
                          lockPaths: fieldValueByName(name:"Lock Paths") {
                            ... on ProjectV2ItemFieldTextValue { text }
                          }
                          lockOwner: fieldValueByName(name:"Lock Owner") {
                            ... on ProjectV2ItemFieldTextValue { text }
                          }
                          lockType: fieldValueByName(name:"Lock Type") {
                            ... on ProjectV2ItemFieldSingleSelectValue { name }
                          }
                          lockExpiry: fieldValueByName(name:"Lock Expiry") {
                            ... on ProjectV2ItemFieldDateValue { date }
                          }
                        }
                      }
                    }
                  }
                }
              `;
              const res = await github.graphql(query, { owner, repo, number: issueNumber });
              const items = res.repository.issue.projectItems.nodes || [];
              const item = items.find(i => i.project.id === projectId);
              if (!item) {
                core.setFailed(`Issue #${issueNumber} is not linked to the required Project lock board`);
                return;
              }
              lockPaths = String(item.lockPaths?.text || '')
                .split(',')
                .map(s => s.trim())
                .filter(Boolean);
              lockOwner = String(item.lockOwner?.text || '').trim();
              lockType = String(item.lockType?.name || '').trim().toLowerCase();
              lockExpiry = String(item.lockExpiry?.date || '').trim();
            } else {
              const lockLine = parseBodyField('lock_paths');
              lockPaths = lockLine.split(',').map(s => s.trim()).filter(Boolean);
              lockOwner = parseBodyField('lock_owner');
              lockType = parseBodyField('lock_type').toLowerCase();
              lockExpiry = parseBodyField('lock_expiry');
            }

            if (!lockPaths.length) {
              core.setFailed('Missing or empty lock_paths');
              return;
            }
            if (!lockOwner) {
              core.setFailed('Missing lock_owner');
              return;
            }
            if (!lockType) {
              core.setFailed('Missing lock_type');
              return;
            }
            if (!['file', 'dir', 'contract'].includes(lockType)) {
              core.setFailed(`Invalid lock_type: ${lockType}`);
              return;
            }
            if (!lockExpiry || !/^\d{4}-\d{2}-\d{2}$/.test(lockExpiry)) {
              core.setFailed('Missing or invalid lock_expiry (expected YYYY-MM-DD)');
              return;
            }
            if (lockOwner !== pr.user.login) {
              core.setFailed(`Lock Owner mismatch. Expected ${lockOwner}, got ${pr.user.login}`);
              return;
            }
            const today = new Date().toISOString().slice(0, 10);
            if (lockExpiry < today) {
              core.setFailed(`Lock expired on ${lockExpiry}`);
              return;
            }

            const coveredByLock = (file, lockPath) => {
              const p = String(lockPath || '').trim();
              if (!p) return false;
              if (p.endsWith('/')) return file.startsWith(p);
              return file === p || file.startsWith(`${p}/`);
            };

            const missing = [];
            for (const file of changedFiles) {
              const ok = lockPaths.some(p => coveredByLock(file, p));
              if (!ok) missing.push(file);
            }

            if (missing.length) {
              core.setFailed(`Files not covered by lock_paths: ${missing.join(', ')}`);
            } else {
              core.notice('Lock check passed');
            }
